const t=JSON.parse('{"key":"v-808fc0c8","path":"/code/java/common/jvm/classloader.html","title":"类加载器详解","lang":"zh-CN","frontmatter":{"title":"类加载器详解","category":"Java","date":"2020-09-21T00:00:00.000Z","tag":["JVM"],"description":"类加载器详解 回顾一下类加载过程 类加载过程：加载-&gt;连接-&gt;初始化。连接过程又可分为三步：验证-&gt;准备-&gt;解析。 类加载过程 一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。","head":[["meta",{"property":"og:url","content":"https://began-zhao.github.io/code/java/common/jvm/classloader.html"}],["meta",{"property":"og:site_name","content":"咖飞的博客"}],["meta",{"property":"og:title","content":"类加载器详解"}],["meta",{"property":"og:description","content":"类加载器详解 回顾一下类加载过程 类加载过程：加载-&gt;连接-&gt;初始化。连接过程又可分为三步：验证-&gt;准备-&gt;解析。 类加载过程 一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-19T03:27:59.000Z"}],["meta",{"property":"article:author","content":"咖飞"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:published_time","content":"2020-09-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-19T03:27:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"类加载器详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-09-21T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-19T03:27:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"咖飞\\",\\"url\\":\\"https://began-zhao.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"回顾一下类加载过程","slug":"回顾一下类加载过程","link":"#回顾一下类加载过程","children":[]},{"level":2,"title":"类加载器总结","slug":"类加载器总结","link":"#类加载器总结","children":[]},{"level":2,"title":"双亲委派模型","slug":"双亲委派模型","link":"#双亲委派模型","children":[{"level":3,"title":"双亲委派模型介绍","slug":"双亲委派模型介绍","link":"#双亲委派模型介绍","children":[]},{"level":3,"title":"双亲委派模型实现源码分析","slug":"双亲委派模型实现源码分析","link":"#双亲委派模型实现源码分析","children":[]},{"level":3,"title":"双亲委派模型的好处","slug":"双亲委派模型的好处","link":"#双亲委派模型的好处","children":[]},{"level":3,"title":"如果我们不想用双亲委派模型怎么办？","slug":"如果我们不想用双亲委派模型怎么办","link":"#如果我们不想用双亲委派模型怎么办","children":[]}]},{"level":2,"title":"自定义类加载器","slug":"自定义类加载器","link":"#自定义类加载器","children":[]},{"level":2,"title":"推荐阅读","slug":"推荐阅读","link":"#推荐阅读","children":[]}],"git":{"createdTime":1702956479000,"updatedTime":1702956479000,"contributors":[{"name":"z-begun","email":"z-begun@outlook.com","commits":1}]},"readingTime":{"minutes":4.74,"words":1421},"filePathRelative":"code/java/common/jvm/classloader.md","localizedDate":"2020年9月21日","excerpt":"<h1> 类加载器详解</h1>\\n<h2> 回顾一下类加载过程</h2>\\n<p>类加载过程：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p>\\n<figure><img src=\\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/类加载过程.png\\" alt=\\"类加载过程\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>类加载过程</figcaption></figure>\\n<p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</p>","autoDesc":true}');export{t as data};
