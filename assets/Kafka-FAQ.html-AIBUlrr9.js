const e=JSON.parse('{"key":"v-5c32d4d1","path":"/interview/Kafka-FAQ.html","title":"Kafka 部分","lang":"zh-CN","frontmatter":{"title":"Kafka 部分","date":"2020-11-23T00:00:00.000Z","category":"interview","description":"Kafak 知识是对分布式，或者直接说是中间件、消息队列考察点的必问内容 一、概念性问题 1、为什么需要消息队列 解耦： 允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。 冗余：消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的\\"插入-获取-删除\\"范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。 扩展性： 因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。 灵活性 &amp; 峰值处理能力： 在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。 如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。 可恢复性： 系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。 顺序保证： 在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。（Kafka 保证一个 Partition 内的消息的有序性） 缓冲： 有助于控制和优化数据流经过系统的速度， 解决生产消息和消费消息的处理速度不一致的情况。 异步通信： 很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。","head":[["meta",{"property":"og:url","content":"https://began-zhao.github.io/interview/Kafka-FAQ.html"}],["meta",{"property":"og:site_name","content":"咖飞的博客"}],["meta",{"property":"og:title","content":"Kafka 部分"}],["meta",{"property":"og:description","content":"Kafak 知识是对分布式，或者直接说是中间件、消息队列考察点的必问内容 一、概念性问题 1、为什么需要消息队列 解耦： 允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。 冗余：消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的\\"插入-获取-删除\\"范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。 扩展性： 因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。 灵活性 &amp; 峰值处理能力： 在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。 如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。 可恢复性： 系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。 顺序保证： 在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。（Kafka 保证一个 Partition 内的消息的有序性） 缓冲： 有助于控制和优化数据流经过系统的速度， 解决生产消息和消费消息的处理速度不一致的情况。 异步通信： 很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-19T03:27:59.000Z"}],["meta",{"property":"article:author","content":"咖飞"}],["meta",{"property":"article:published_time","content":"2020-11-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-19T03:27:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Kafka 部分\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-11-23T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-19T03:27:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"咖飞\\",\\"url\\":\\"https://began-zhao.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"一、概念性问题","slug":"一、概念性问题","link":"#一、概念性问题","children":[{"level":3,"title":"1、为什么需要消息队列","slug":"_1、为什么需要消息队列","link":"#_1、为什么需要消息队列","children":[]},{"level":3,"title":"2、Kakfa 是什么","slug":"_2、kakfa-是什么","link":"#_2、kakfa-是什么","children":[]},{"level":3,"title":"3、Kafka 使用场景 ？","slug":"_3、kafka-使用场景","link":"#_3、kafka-使用场景","children":[]},{"level":3,"title":"4、Kafka 都有哪些特点？","slug":"_4、kafka-都有哪些特点","link":"#_4、kafka-都有哪些特点","children":[]},{"level":3,"title":"5、Kafka 主要组件有哪些","slug":"_5、kafka-主要组件有哪些","link":"#_5、kafka-主要组件有哪些","children":[]},{"level":3,"title":"6、 Kakfa 核心 API 有哪些","slug":"_6、-kakfa-核心-api-有哪些","link":"#_6、-kakfa-核心-api-有哪些","children":[]}]},{"level":2,"title":"二、架构 | 原理和设计","slug":"二、架构-原理和设计","link":"#二、架构-原理和设计","children":[{"level":3,"title":"7、 Kafka 的设计架构你知道吗？","slug":"_7、-kafka-的设计架构你知道吗","link":"#_7、-kafka-的设计架构你知道吗","children":[]},{"level":3,"title":"8、Zookeeper 在 Kafka 中的作用","slug":"_8、zookeeper-在-kafka-中的作用","link":"#_8、zookeeper-在-kafka-中的作用","children":[]},{"level":3,"title":"9、没有 Zookeeper ， Kafka 能用吗？","slug":"_9、没有-zookeeper-kafka-能用吗","link":"#_9、没有-zookeeper-kafka-能用吗","children":[]},{"level":3,"title":"Kafka 判断一个节点是否存活有什么条件","slug":"kafka-判断一个节点是否存活有什么条件","link":"#kafka-判断一个节点是否存活有什么条件","children":[]},{"level":3,"title":"10、Kafka 分区的目的？","slug":"_10、kafka-分区的目的","link":"#_10、kafka-分区的目的","children":[]},{"level":3,"title":"11、Kafka 的多副本机制了解吗","slug":"_11、kafka-的多副本机制了解吗","link":"#_11、kafka-的多副本机制了解吗","children":[]},{"level":3,"title":"12、 Kafka 副本机制的好处","slug":"_12、-kafka-副本机制的好处","link":"#_12、-kafka-副本机制的好处","children":[]},{"level":3,"title":"13、 kafka 数据可靠性保证|实现？","slug":"_13、-kafka-数据可靠性保证-实现","link":"#_13、-kafka-数据可靠性保证-实现","children":[]},{"level":3,"title":"14、ISR、OSR、AR 是什么？","slug":"_14、isr、osr、ar-是什么","link":"#_14、isr、osr、ar-是什么","children":[]},{"level":3,"title":"15、producer 写入消息流程？","slug":"_15、producer-写入消息流程","link":"#_15、producer-写入消息流程","children":[]},{"level":3,"title":"16、Kafka消息是采用 Pull 模式，还是 Push 模式？","slug":"_16、kafka消息是采用-pull-模式-还是-push-模式","link":"#_16、kafka消息是采用-pull-模式-还是-push-模式","children":[]},{"level":3,"title":"17、Kafka 高效文件存储设计特点","slug":"_17、kafka-高效文件存储设计特点","link":"#_17、kafka-高效文件存储设计特点","children":[]},{"level":3,"title":"18、为什么要有消费者组 | 消费者和消费者组有什么关系？","slug":"_18、为什么要有消费者组-消费者和消费者组有什么关系","link":"#_18、为什么要有消费者组-消费者和消费者组有什么关系","children":[]},{"level":3,"title":"Kafak 判断节点存活的两个条件","slug":"kafak-判断节点存活的两个条件","link":"#kafak-判断节点存活的两个条件","children":[]},{"level":3,"title":"请谈一谈 Kafka 数据一致性原理","slug":"请谈一谈-kafka-数据一致性原理","link":"#请谈一谈-kafka-数据一致性原理","children":[]},{"level":3,"title":"13、Kafka 的每个分区只能被一个消费者线程，如何做到多个线程同时消费一个分区？","slug":"_13、kafka-的每个分区只能被一个消费者线程-如何做到多个线程同时消费一个分区","link":"#_13、kafka-的每个分区只能被一个消费者线程-如何做到多个线程同时消费一个分区","children":[]},{"level":3,"title":"14、数据传输的事务有几种？","slug":"_14、数据传输的事务有几种","link":"#_14、数据传输的事务有几种","children":[]},{"level":3,"title":"15、Kafka 消费者是否可以消费指定分区消息？","slug":"_15、kafka-消费者是否可以消费指定分区消息","link":"#_15、kafka-消费者是否可以消费指定分区消息","children":[]},{"level":3,"title":"20、Kafka创建Topic时如何将分区放置到不同的Broker中","slug":"_20、kafka创建topic时如何将分区放置到不同的broker中","link":"#_20、kafka创建topic时如何将分区放置到不同的broker中","children":[]},{"level":3,"title":"Kafka 的 ack 机制","slug":"kafka-的-ack-机制","link":"#kafka-的-ack-机制","children":[]},{"level":3,"title":"如何控制消费的位置","slug":"如何控制消费的位置","link":"#如何控制消费的位置","children":[]}]},{"level":2,"title":"三、实践相关","slug":"三、实践相关","link":"#三、实践相关","children":[{"level":3,"title":"Kafka 如何保证消息不丢失","slug":"kafka-如何保证消息不丢失","link":"#kafka-如何保证消息不丢失","children":[]},{"level":3,"title":"Kafka 如何保证消息的顺序消费","slug":"kafka-如何保证消息的顺序消费","link":"#kafka-如何保证消息的顺序消费","children":[]},{"level":3,"title":"如何保证消息不被重复消费？","slug":"如何保证消息不被重复消费","link":"#如何保证消息不被重复消费","children":[]},{"level":3,"title":"Kafka 消息积压问题？","slug":"kafka-消息积压问题","link":"#kafka-消息积压问题","children":[]},{"level":3,"title":"21、Kafka 新建的分区会在哪个目录下创建","slug":"_21、kafka-新建的分区会在哪个目录下创建","link":"#_21、kafka-新建的分区会在哪个目录下创建","children":[]},{"level":3,"title":"22、谈一谈 Kafka 的再均衡","slug":"_22、谈一谈-kafka-的再均衡","link":"#_22、谈一谈-kafka-的再均衡","children":[]},{"level":3,"title":"22、Kafka 为什么能那么快 | Kafka高效读写数据的原因 | 吞吐量大的原因？","slug":"_22、kafka-为什么能那么快-kafka高效读写数据的原因-吞吐量大的原因","link":"#_22、kafka-为什么能那么快-kafka高效读写数据的原因-吞吐量大的原因","children":[]}]},{"level":2,"title":"四、其他","slug":"四、其他","link":"#四、其他","children":[{"level":3,"title":"Kafka 消息最大多大","slug":"kafka-消息最大多大","link":"#kafka-消息最大多大","children":[]}]}],"git":{"createdTime":1702956479000,"updatedTime":1702956479000,"contributors":[{"name":"z-begun","email":"z-begun@outlook.com","commits":1}]},"readingTime":{"minutes":39.47,"words":11840},"filePathRelative":"interview/Kafka-FAQ.md","localizedDate":"2020年11月23日","excerpt":"<blockquote>\\n<p>Kafak 知识是对分布式，或者直接说是中间件、消息队列考察点的必问内容</p>\\n</blockquote>\\n<h2> 一、概念性问题</h2>\\n<h3> 1、为什么需要消息队列</h3>\\n<ol>\\n<li><strong>解耦</strong>： 允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</li>\\n<li><strong>冗余</strong>：消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的\\"插入-获取-删除\\"范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</li>\\n<li><strong>扩展性</strong>： 因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。</li>\\n<li><strong>灵活性 &amp; 峰值处理能力</strong>： 在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。 如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</li>\\n<li><strong>可恢复性</strong>： 系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</li>\\n<li><strong>顺序保证</strong>： 在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。（Kafka 保证一个 Partition 内的消息的有序性）</li>\\n<li><strong>缓冲</strong>： 有助于控制和优化数据流经过系统的速度， 解决生产消息和消费消息的处理速度不一致的情况。</li>\\n<li><strong>异步通信</strong>： 很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</li>\\n</ol>","autoDesc":true}');export{e as data};
