const e=JSON.parse('{"key":"v-691bceb3","path":"/code/java/distributed-system/cache/cache-king-2.html","title":"缓存之王-下","lang":"zh-CN","frontmatter":{"title":"缓存之王-下","icon":"cache","date":"2024-04-10T00:00:00.000Z","description":"在前面缓存之王上篇中，已经对于本地缓存的选型及优缺点做了分析， 但是随着互联网的快速发展，分布式系统已经成为了解决大规模并发请求、高可用性、高扩展性等问题的重要手段。所以合理的设计分布式缓存策略以及使用多级缓存来提高并发瓶颈对于系统整体的性能提升也具有重要的意义。 分布式缓存同本地缓存一样本质也是通过将数据存储在内存中，加快数据访问速度，避免频繁访问数...","head":[["meta",{"property":"og:url","content":"https://began-zhao.github.io/begun-blog/code/java/distributed-system/cache/cache-king-2.html"}],["meta",{"property":"og:site_name","content":"咖飞"}],["meta",{"property":"og:title","content":"缓存之王-下"}],["meta",{"property":"og:description","content":"在前面缓存之王上篇中，已经对于本地缓存的选型及优缺点做了分析， 但是随着互联网的快速发展，分布式系统已经成为了解决大规模并发请求、高可用性、高扩展性等问题的重要手段。所以合理的设计分布式缓存策略以及使用多级缓存来提高并发瓶颈对于系统整体的性能提升也具有重要的意义。 分布式缓存同本地缓存一样本质也是通过将数据存储在内存中，加快数据访问速度，避免频繁访问数..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-23T03:01:43.000Z"}],["meta",{"property":"article:author","content":"咖飞"}],["meta",{"property":"article:published_time","content":"2024-04-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-23T03:01:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"缓存之王-下\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-10T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-23T03:01:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"咖飞\\",\\"url\\":\\"https://began-zhao.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"缓存的查询","slug":"缓存的查询","link":"#缓存的查询","children":[]},{"level":2,"title":"缓存的更新","slug":"缓存的更新","link":"#缓存的更新","children":[]},{"level":2,"title":"1、先更新数据库再更新缓存","slug":"_1、先更新数据库再更新缓存","link":"#_1、先更新数据库再更新缓存","children":[]},{"level":2,"title":"2、先更新缓存再更新数据库","slug":"_2、先更新缓存再更新数据库","link":"#_2、先更新缓存再更新数据库","children":[]},{"level":2,"title":"3、先删除缓存再更新数据库","slug":"_3、先删除缓存再更新数据库","link":"#_3、先删除缓存再更新数据库","children":[]},{"level":2,"title":"4、先更新数据库再删除缓存（cache aside）","slug":"_4、先更新数据库再删除缓存-cache-aside","link":"#_4、先更新数据库再删除缓存-cache-aside","children":[]},{"level":2,"title":"5、其他问题","slug":"_5、其他问题","link":"#_5、其他问题","children":[]},{"level":2,"title":"5.1、可保障的重试机制","slug":"_5-1、可保障的重试机制","link":"#_5-1、可保障的重试机制","children":[]},{"level":2,"title":"5.2、订阅数据库 binlog","slug":"_5-2、订阅数据库-binlog","link":"#_5-2、订阅数据库-binlog","children":[]}],"git":{"createdTime":1713841303000,"updatedTime":1713841303000,"contributors":[{"name":"z-begun","email":"z-begun@outlook.com","commits":1}]},"readingTime":{"minutes":10.72,"words":3216},"filePathRelative":"code/java/distributed-system/cache/cache-king-2.md","localizedDate":"2024年4月10日","excerpt":"","autoDesc":true}');export{e as data};
